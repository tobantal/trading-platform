# Отчёт по защите курсовой работы

## Тема: Биржевая торговля с использованием микросервисной архитектуры

**Студент:** Антон Тоболкин  
**Курс:** OTUS Microservice Architecture  
**Дата:** Январь 2026

---

## Содержание

1. [Вопрос 1: Паттерны гарантированной доставки сообщений](#вопрос-1-паттерны-гарантированной-доставки-сообщений)
2. [Вопрос 2: Архитектура масштабирования](#вопрос-2-архитектура-масштабирования)
3. [Заключение](#заключение)

---

## Вопрос 1: Паттерны гарантированной доставки сообщений

### 1.1 Введение

RabbitMQ как брокер сообщений сам по себе не гарантирует доставку — это лишь транспортный механизм. Для обеспечения надёжной доставки сообщений в распределённой системе необходимо применять специализированные паттерны на уровне приложения.

### 1.2 Реализованные паттерны

#### 1.2.1 Manual Acknowledgment (Ручное подтверждение)

Паттерн обеспечивает гарантию того, что сообщение не будет удалено из очереди до успешной обработки consumer'ом.

**Реализация в проекте:**

```cpp
// RabbitMQAdapter.cpp
channel_->consume(queueName_)
    .onReceived([this](const AMQP::Message& msg, uint64_t tag, bool) {
        std::string routingKey = msg.routingkey();
        std::string body(msg.body(), msg.bodySize());
        
        // Вызов обработчиков
        auto it = handlers_.find(routingKey);
        if (it != handlers_.end()) {
            for (const auto& handler : it->second) {
                try {
                    handler(routingKey, body);
                } catch (const std::exception& e) {
                    std::cerr << "Handler error: " << e.what() << std::endl;
                }
            }
        }
        
        // ACK только ПОСЛЕ успешной обработки
        channel_->ack(tag);
    });
```

**Принцип работы:**

```
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│  Producer   │──────│  RabbitMQ   │──────│  Consumer   │
└─────────────┘      └──────┬──────┘      └──────┬──────┘
                            │                    │
                            │  1. Deliver msg    │
                            │───────────────────▶│
                            │                    │
                            │                    │ 2. Process
                            │                    │
                            │  3. ACK            │
                            │◀───────────────────│
                            │                    │
                            │  4. Delete from    │
                            │     queue          │
                            │                    │
```

**Гарантия:** Если consumer падает до отправки ACK, сообщение автоматически возвращается в очередь и будет доставлено другому consumer'у.

#### 1.2.2 Персистентность в RabbitMQ (три уровня)

**Важно понимать:** `AMQP::durable` — это **декларативный флаг**, который передаётся RabbitMQ серверу. Вся работа по сохранению происходит на стороне **сервера** (в Mnesia — встроенной базе данных Erlang/OTP), а не в клиентском коде.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         КАК РАБОТАЕТ DURABLE                                │
└─────────────────────────────────────────────────────────────────────────────┘

  AMQP-CPP Client                              RabbitMQ Server
       │                                             │
       │  AMQP.Exchange.Declare                      │
       │  {                                          │
       │    exchange: "trading.events"               │
       │    type: "topic"                            │
       │    durable: true  ←── декларативный флаг    │
       │  }                                          │
       │────────────────────────────────────────────▶│
       │                                             │
       │                                             │   ┌─────────────────────┐
       │                                             │   │ Mnesia Database     │
       │                                             │   │ (Erlang/OTP)        │
       │                                             │   │                     │
       │                                             │──▶│ Сохранение metadata │
       │                                             │   │  exchange на диск   │
       │                                             │   └─────────────────────┘
       │                                             │
       │  Exchange.Declare-Ok                        │
       │◀────────────────────────────────────────────│
```

**Три уровня персистентности в RabbitMQ:**

| Уровень | Флаг | Что сохраняется | Что НЕ сохраняется |
|---------|------|-----------------|-------------------|
| 1. Durable Exchange | `AMQP::durable` | Метаданные exchange | Сообщения (exchange их не хранит) |
| 2. Durable Queue | `AMQP::durable` | Метаданные очереди + persistent сообщения | Transient сообщения |
| 3. Persistent Message | `delivery_mode=2` | Тело сообщения на диск | — |

**Для полной персистентности необходимы ВСЕ ТРИ уровня:**

```cpp
// 1. Durable Exchange (метаданные exchange переживут рестарт)
channel_->declareExchange("trading.events", AMQP::topic, AMQP::durable);

// 2. Durable Queue (метаданные очереди переживут рестарт)  
channel_->declareQueue("order-processing", AMQP::durable);

// 3. Persistent Message (сообщение записывается на диск)
AMQP::Envelope envelope(messageBody);
envelope.setDeliveryMode(2);  // 2 = persistent, 1 = transient
channel_->publish("trading.events", "order.created", envelope);
```

**Текущая реализация в проекте:**

```cpp
// Exchange - durable ✅
channel_->declareExchange(exchangeName_, AMQP::topic, AMQP::durable)
    .onSuccess([this]() {
        std::cout << "Exchange declared: " << exchangeName_ << std::endl;
        setupQueue();
    });

// Queue - exclusive (НЕ durable!) ⚠️
channel_->declareQueue(AMQP::exclusive)  // exclusive = auto-delete, не переживёт рестарт

// Publish - без явного delivery_mode ⚠️
channel_->publish(exchangeName_, routingKey, message);  // default = transient
```

**Текущий статус и рекомендации:**

| Компонент | Текущий статус | Рекомендация для production |
|-----------|----------------|----------------------------|
| Exchange | ✅ Durable | — |
| Queue | ⚠️ Exclusive | Использовать `AMQP::durable` |
| Messages | ⚠️ Transient | Устанавливать `delivery_mode=2` |

**Рекомендуемая реализация для production:**

```cpp
void RabbitMQAdapter::setupQueue() {
    // Durable queue вместо exclusive
    channel_->declareQueue(queueName_, AMQP::durable)
        .onSuccess([this](const std::string& name, uint32_t, uint32_t) {
            queueName_ = name;
            applyPendingBindings();
            startConsuming();
        });
}

void RabbitMQAdapter::publish(const std::string& routingKey, 
                               const std::string& message) {
    AMQP::Envelope envelope(message.data(), message.size());
    envelope.setDeliveryMode(2);  // Persistent!
    
    channel_->publish(exchangeName_, routingKey, envelope);
}
```

#### 1.2.3 Idempotency Pattern (Идемпотентность)

Защита от дублирования бизнес-операций при повторной доставке сообщений.

**Реализация в проекте:**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         IDEMPOTENCY FLOW                                    │
└─────────────────────────────────────────────────────────────────────────────┘

  Client              Trading Service           PostgreSQL
    │                       │                       │
    │ POST /orders          │                       │
    │ X-Idempotency-Key:    │                       │
    │   "ord-uuid-123"      │                       │
    │──────────────────────▶│                       │
    │                       │                       │
    │                       │ SELECT * FROM         │
    │                       │ idempotency_keys      │
    │                       │ WHERE key='ord-...'   │
    │                       │──────────────────────▶│
    │                       │                       │
    │                       │◀──────────────────────│
    │                       │                       │
    │                       │ ┌─────────────────────────────────────┐
    │                       │ │ IF NOT FOUND:                       │
    │                       │ │   1. Process order                  │
    │                       │ │   2. Save to idempotency_keys       │
    │                       │ │   3. Return new response            │
    │                       │ │                                     │
    │                       │ │ IF FOUND:                           │
    │                       │ │   Return cached response            │
    │                       │ └─────────────────────────────────────┘
    │                       │                       │
    │ 201 {order_id: ...}   │                       │
    │◀──────────────────────│                       │
```

**Структура таблицы:**

```sql
CREATE TABLE idempotency_keys (
    key VARCHAR(255) PRIMARY KEY,
    status_code INTEGER NOT NULL,
    response_body TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP
);

CREATE INDEX idx_idempotency_expires ON idempotency_keys(expires_at);
```

### 1.3 Рекомендуемые паттерны для production

#### 1.3.1 Transactional Outbox Pattern

Обеспечивает атомарность операций "запись в БД + отправка события".

**Проблема:** При раздельных операциях возможны несогласованности:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ПРОБЛЕМА БЕЗ OUTBOX                                 │
└─────────────────────────────────────────────────────────────────────────────┘

  Сценарий 1: БД записана, событие не отправлено (crash после commit)
  Сценарий 2: Событие отправлено, БД не записана (crash до commit)
```

**Решение:**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      TRANSACTIONAL OUTBOX                                   │
└─────────────────────────────────────────────────────────────────────────────┘

  Order Service                    PostgreSQL                     RabbitMQ
       │                               │                              │
       │  BEGIN TRANSACTION            │                              │
       │──────────────────────────────▶│                              │
       │                               │                              │
       │  INSERT INTO orders (...)     │                              │
       │──────────────────────────────▶│                              │
       │                               │                              │
       │  INSERT INTO outbox (         │                              │
       │    event_type,                │                              │
       │    payload,                   │                              │
       │    created_at                 │                              │
       │  )                            │                              │
       │──────────────────────────────▶│                              │
       │                               │                              │
       │  COMMIT                       │                              │
       │──────────────────────────────▶│                              │
       │                               │                              │
       │                               │                              │
  Outbox Poller                        │                              │
       │                               │                              │
       │  SELECT * FROM outbox         │                              │
       │  WHERE sent = false           │                              │
       │  FOR UPDATE SKIP LOCKED       │                              │
       │──────────────────────────────▶│                              │
       │                               │                              │
       │                               │      Publish event           │
       │───────────────────────────────┼─────────────────────────────▶│
       │                               │                              │
       │  UPDATE outbox                │                              │
       │  SET sent = true              │                              │
       │──────────────────────────────▶│                              │
```

**Структура таблицы outbox:**

```sql
CREATE TABLE outbox (
    id BIGSERIAL PRIMARY KEY,
    event_type VARCHAR(100) NOT NULL,
    aggregate_id VARCHAR(255) NOT NULL,
    payload JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    sent BOOLEAN DEFAULT FALSE,
    sent_at TIMESTAMP
);

CREATE INDEX idx_outbox_unsent ON outbox(sent, created_at) WHERE sent = false;
```

#### 1.3.2 Publisher Confirms

Подтверждение от брокера о приёме сообщения.

```cpp
// Рекомендуемая реализация
channel_->confirmSelect()
    .onAck([](uint64_t deliveryTag, bool multiple) {
        // Сообщение успешно принято брокером
        markAsSent(deliveryTag);
    })
    .onNack([](uint64_t deliveryTag, bool multiple, bool requeue) {
        // Сообщение отклонено — retry или сохранить в outbox
        scheduleRetry(deliveryTag);
    });
```

### 1.4 Сводная таблица паттернов

| Паттерн | Статус | Гарантия | Уровень |
|---------|--------|----------|---------|
| Manual Acknowledgment | ✅ Реализован | Сообщение не теряется при падении consumer | Consumer |
| Durable Exchange | ✅ Реализован | Exchange переживает рестарт RabbitMQ | Broker |
| Durable Queue | ⚠️ Не реализован | Очередь переживает рестарт RabbitMQ | Broker |
| Persistent Messages | ⚠️ Не реализован | Сообщения сохраняются на диск | Producer |
| Idempotency Key | ✅ Реализован | Защита от дублирования бизнес-операций | Application |
| Transactional Outbox | 📋 Рекомендуется | Атомарность "БД + событие" | Producer |
| Publisher Confirms | 📋 Рекомендуется | Подтверждение доставки до брокера | Producer |
| Dead Letter Queue | 📋 Рекомендуется | Обработка "отравленных" сообщений | Consumer |

**Примечание:** Для полной гарантии сохранности сообщений при рестарте RabbitMQ необходимо реализовать Durable Queue и Persistent Messages.

### 1.5 Диаграмма полного цикла гарантированной доставки

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    ПОЛНЫЙ ЦИКЛ ГАРАНТИРОВАННОЙ ДОСТАВКИ                     │
└─────────────────────────────────────────────────────────────────────────────┘

  Client            Trading Service       trading_db        RabbitMQ       Broker Service
    │                     │                   │                │                 │
    │ ════════════════════════════════════════════════════════════════════════════
    │                 1. IDEMPOTENCY (защита от дублей HTTP-запросов)
    │ ════════════════════════════════════════════════════════════════════════════
    │                     │                   │                │                 │
    │  POST /orders       │                   │                │                 │
    │  X-Idempotency-Key  │                   │                │                 │
    │────────────────────▶│                   │                │                 │
    │                     │                   │                │                 │
    │                     │  SELECT * FROM    │                │                 │
    │                     │  idempotency_keys │                │                 │
    │                     │──────────────────▶│                │                 │
    │                     │                   │                │                 │
    │                     │  NOT FOUND        │                │                 │
    │                     │◀──────────────────│                │                 │
    │                     │                   │                │                 │
    │ ════════════════════════════════════════════════════════════════════════════
    │                 2. TRANSACTIONAL OUTBOX (атомарность БД + событие)
    │ ════════════════════════════════════════════════════════════════════════════
    │                     │                   │                │                 │
    │                     │  BEGIN            │                │                 │
    │                     │──────────────────▶│                │                 │
    │                     │  INSERT order     │                │                 │
    │                     │──────────────────▶│                │                 │
    │                     │  INSERT outbox    │                │                 │
    │                     │──────────────────▶│                │                 │
    │                     │  INSERT idemp_key │                │                 │
    │                     │──────────────────▶│                │                 │
    │                     │  COMMIT           │                │                 │
    │                     │──────────────────▶│                │                 │
    │                     │                   │                │                 │
    │  201 {order_id}     │                   │                │                 │
    │◀────────────────────│                   │                │                 │
    │                     │                   │                │                 │
    │ ════════════════════════════════════════════════════════════════════════════
    │                 3. PUBLISHER CONFIRMS (подтверждение от брокера)
    │ ════════════════════════════════════════════════════════════════════════════
    │                     │                   │                │                 │
    │               [Outbox Poller]           │                │                 │
    │                     │                   │                │                 │
    │                     │  Publish + confirm│                │                 │
    │                     │────────────────────────────────────▶                 │
    │                     │                   │      ACK       │                 │
    │                     │◀────────────────────────────────────│                 │
    │                     │                   │                │                 │
    │                     │  UPDATE outbox    │                │                 │
    │                     │  SET sent=true    │                │                 │
    │                     │──────────────────▶│                │                 │
    │                     │                   │                │                 │
    │ ════════════════════════════════════════════════════════════════════════════
    │                 4. CONSUMER ACK (подтверждение обработки сообщения)
    │ ════════════════════════════════════════════════════════════════════════════
    │                     │                   │                │                 │
    │                     │                   │                │  Deliver        │
    │                     │                   │                │────────────────▶│
    │                     │                   │                │                 │
    │                     │                   │                │  Process order  │
    │                     │                   │                │  (execute,      │
    │                     │                   │                │   update pos)   │
    │                     │                   │                │                 │
    │                     │                   │                │  ACK            │
    │                     │                   │                │◀────────────────│
    │                     │                   │                │                 │
```

**Уровни защиты:**

| # | Механизм | Где | От чего защищает |
|---|----------|-----|------------------|
| 1 | Idempotency Key | Trading Service | Повторные HTTP-запросы от клиента |
| 2 | Transactional Outbox | Trading Service | Потеря события при crash после commit |
| 3 | Publisher Confirms | Trading Service → RabbitMQ | Потеря сообщения до записи в очередь |
| 4 | Consumer ACK | Broker Service → RabbitMQ | Потеря сообщения при падении consumer |

---

## Вопрос 2: Архитектура масштабирования

### 2.1 Анализ требований

При значительном увеличении числа заявок и пользователей возникают следующие узкие места:

| Компонент | Проблема при росте нагрузки |
|-----------|----------------------------|
| Order processing | CPU-bound, конкурентный доступ к балансам |
| Quote generation | Частые обновления, высокий read throughput |
| Database | Блокировки, I/O bottleneck |
| Message broker | Пропускная способность очередей |

### 2.2 Предлагаемое решение

#### 2.2.1 Разделение Broker Service

Текущий `broker-service` объединяет две разные по характеру нагрузки функции:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     ТЕКУЩАЯ АРХИТЕКТУРА                                     │
└─────────────────────────────────────────────────────────────────────────────┘

                        ┌─────────────────────┐
                        │   broker-service    │
                        │                     │
                        │  • Quote generation │  ← Один источник, broadcast
                        │  • Order processing │  ← Много источников, per-user
                        │  • Portfolio mgmt   │
                        │                     │
                        └─────────────────────┘
```

**Предлагаемое разделение:**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     ЦЕЛЕВАЯ АРХИТЕКТУРА                                     │
└─────────────────────────────────────────────────────────────────────────────┘

  ┌─────────────────────┐              ┌─────────────────────┐
  │   market-service    │              │   order-service     │
  │   (1 инстанс)       │              │   (N инстансов)     │
  │                     │              │                     │
  │  • Quote generation │              │  • Order processing │
  │  • Price feeds      │              │  • Portfolio mgmt   │
  │  • Market data API  │              │  • Balance ops      │
  │                     │              │                     │
  │  Характер: broadcast│              │  Характер: per-user │
  │  Масштабирование:   │              │  Масштабирование:   │
  │    вертикальное     │              │    горизонтальное   │
  └─────────────────────┘              └─────────────────────┘
```

**Зоны ответственности:**

| Сервис | Ответственность | Масштабирование |
|--------|-----------------|-----------------|
| **market-service** | Генерация и распространение котировок | Вертикальное (1 инстанс, мощное железо) |
| **order-service** | Обработка ордеров, управление позициями | Горизонтальное (N инстансов, партиционирование) |

#### 2.2.2 Стратегия хранения данных

**Классификация данных по характеру доступа:**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      КЛАССИФИКАЦИЯ ДАННЫХ                                   │
└─────────────────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────────────┐
  │ СТАТИЧЕСКИЕ ДАННЫЕ (редко меняются)                                     │
  │                                                                         │
  │   • Instruments (FIGI, ticker, name, lot)                               │
  │   • Users (credentials, profile)                                        │
  │                                                                         │
  │   Хранилище: PostgreSQL + LRU Cache (TTL: 5-60 минут)                   │
  └─────────────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────────────┐
  │ ТРАНЗАКЦИОННЫЕ ДАННЫЕ (требуют ACID)                                    │
  │                                                                         │
  │   • Orders (создание, изменение статуса)                                │
  │   • Balances (резервирование, списание)                                 │
  │   • Positions (изменение количества)                                    │
  │                                                                         │
  │   Хранилище: PostgreSQL (sharded by account_id)                         │
  └─────────────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────────────┐
  │ ВЫСОКОЧАСТОТНЫЕ ДАННЫЕ (допускают eventual consistency)                 │
  │                                                                         │
  │   • Current quotes (последняя цена)                                     │
  │   • Order status cache (для быстрого чтения)                            │
  │   • Session tokens                                                      │
  │                                                                         │
  │   Хранилище: Redis + LRU Cache (TTL: 1-10 секунд)                       │
  └─────────────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────────────┐
  │ ИСТОРИЧЕСКИЕ ДАННЫЕ (append-only, time-series)                          │
  │                                                                         │
  │   • Quote history (свечи, тики)                                         │
  │   • Order history (исполненные ордера)                                  │
  │   • Audit log                                                           │
  │                                                                         │
  │   Хранилище: TimescaleDB (партиционирование по времени)                 │
  └─────────────────────────────────────────────────────────────────────────┘
```

**Итоговая таблица хранилищ:**

| Данные | Хранилище | Причина выбора |
|--------|-----------|----------------|
| Instruments | PostgreSQL + LRU Cache | Справочные данные, редко меняются |
| Users/Auth | PostgreSQL + Redis sessions | ACID для регистрации, скорость для авторизации |
| Orders (active) | PostgreSQL (sharded) | ACID критичен для финансовых операций |
| Orders (history) | TimescaleDB | Партиционирование по времени, эффективные range-запросы |
| Balances | PostgreSQL (master) | ACID обязателен, eventual consistency недопустима |
| Quotes (current) | Redis Pub/Sub + Cache | Максимальная скорость, допустима потеря |
| Quotes (history) | TimescaleDB | Time-series оптимизация |

#### 2.2.3 CQRS (Command Query Responsibility Segregation)

Разделение моделей чтения и записи для оптимизации под разные паттерны нагрузки.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           CQRS АРХИТЕКТУРА                                  │
└─────────────────────────────────────────────────────────────────────────────┘

          COMMANDS (Write)                      QUERIES (Read)
               │                                     │
               ▼                                     ▼
        ┌──────────────┐                       ┌─────────────┐
        │order-service │                       │query-service│
        │              │                       │             │
        │ Валидация    │                       │ Агрегация   │
        │ Бизнес-логика│                       │ Проекции    │
        │ Транзакции   │                       │ Кэширование │
        └──────┬───────┘                       └─────┬───────┘
               │                                     │
               │                                     │
               ▼                                     ▼
        ┌─────────────┐     Events            ┌─────────────┐
        │ PostgreSQL  │ ─────────────────────▶│   Redis     │
        │  (master)   │     (RabbitMQ)        │(read model) │
        │             │                       │             │
        │ • Orders    │                       │ • Portfolio │
        │ • Balances  │                       │ • Positions │
        │ • Positions │                       │ • Orders    │
        └─────────────┘                       └─────────────┘
              │                                     │
              │                                     │
              │         CONSISTENCY                 │
              │                                     │
              │  Write: Strong (ACID)               │
              │  Read: Eventual (async sync)        │
              │                                     │
```

**Преимущества:**

- Write-модель оптимизирована для транзакций (нормализация, индексы для записи)
- Read-модель оптимизирована для запросов (денормализация, кэширование)
- Независимое масштабирование read и write нагрузки

#### 2.2.4 Горизонтальное партиционирование

Распределение данных по нескольким инстансам на основе `account_id`.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                   ПАРТИЦИОНИРОВАНИЕ ПО ACCOUNT_ID                           │
└─────────────────────────────────────────────────────────────────────────────┘

                              ┌─────────────────┐
                              │  Load Balancer  │
                              │                 │
                              │ Routing:        │
                              │ hash(account_id)│
                              │    % N          │
                              └────────┬────────┘
                                       │
           ┌───────────────────────────┼───────────────────────────┐
           │                           │                           │
           ▼                           ▼                           ▼
    ┌─────────────┐             ┌─────────────┐             ┌─────────────┐
    │order-svc-1  │             │order-svc-2  │             │order-svc-3  │
    │             │             │             │             │             │
    │accounts:    │             │accounts:    │             │accounts:    │
    │ hash % 3 = 0│             │ hash % 3 = 1│             │ hash % 3 = 2│
    └──────┬──────┘             └──────┬──────┘             └──────┬──────┘
           │                           │                           │
           ▼                           ▼                           ▼
    ┌─────────────┐             ┌─────────────┐             ┌─────────────┐
    │ PostgreSQL  │             │ PostgreSQL  │             │ PostgreSQL  │
    │ partition-1 │             │ partition-2 │             │ partition-3 │
    └─────────────┘             └─────────────┘             └─────────────┘
```

**Преимущества:**

- Все данные одного пользователя на одном шарде — нет распределённых транзакций
- Линейное масштабирование пропускной способности
- Изоляция отказов — падение одного шарда не влияет на других пользователей

**Алгоритм роутинга:**

```cpp
class ConsistentHashRouter {
public:
    int getPartition(const std::string& accountId, int numPartitions) {
        size_t hash = std::hash<std::string>{}(accountId);
        return hash % numPartitions;
    }
};
```

### 2.3 Финальная архитектура

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    МАСШТАБИРУЕМАЯ АРХИТЕКТУРА                               │
└─────────────────────────────────────────────────────────────────────────────┘

                                    Internet
                                        │
                                        ▼
                              ┌───────────────────┐
                              │     NGINX         │
                              │  Load Balancer    │
                              │                   │
                              │ • SSL termination │
                              │ • Rate limiting   │
                              │ • Routing         │
                              └────────┬──────────┘
                                       │
        ┌──────────────────────────────┼──────────────────────────────┐
        │                              │                              │
        ▼                              ▼                              ▼
  ┌───────────┐                 ┌───────────┐                 ┌───────────┐
  │ gateway-1 │                 │ gateway-2 │                 │ gateway-N │
  │(stateless)│                 │(stateless)│                 │(stateless)│
  └─────┬─────┘                 └─────┬─────┘                 └─────┬─────┘
        │                             │                             │
        └─────────────────────────────┼─────────────────────────────┘
                                      │
     ┌────────────────┬───────────────┼───────────────┬────────────────┐
     │                │               │               │                │
     ▼                ▼               ▼               ▼                ▼
┌──────────┐    ┌─────────┐    ┌───────────┐    ┌───────────┐    ┌───────────┐
│  auth    │    │ market  │    │order-svc-1│    │order-svc-2│    │order-svc-N│
│ service  │    │ service │    │           │    │           │    │           │
│          │    │         │    │partition 1│    │partition 2│    │partition N│
│(replicas)│    │(1 inst) │    │           │    │           │    │           │
└────┬─────┘    └───┬─────┘    └────┬──────┘    └───┬───────┘    └───┬───────┘
     │              │               │               │                │
     │              │               │               │                │
     ▼              ▼               └───────────────┼────────────────┘
┌─────────┐   ┌─────────┐                           │
│  Redis  │   │  Redis  │                           ▼
│Sessions │   │ Pub/Sub │                    ┌─────────────┐
│  Cache  │   │ Quotes  │                    │ PostgreSQL  │
└─────────┘   └─────────┘                    │  Sharded    │
                                             │             │
                                             │ • Orders    │
                                             │ • Balances  │
                                             │ • Positions │
                                             └─────────────┘

                              ┌─────────────┐
                              │  RabbitMQ   │
                              │  Cluster    │
                              │             │
                              │ • Events    │
                              │ • Commands  │
                              └─────────────┘

                              ┌─────────────┐
                              │ TimescaleDB │
                              │             │
                              │ • History   │
                              │ • Analytics │
                              └─────────────┘
```

### 2.4 Характеристики масштабирования

| Компонент | Тип масштабирования | Механизм |
|-----------|---------------------|----------|
| Gateway | Горизонтальное | Stateless, любое количество |
| Auth Service | Горизонтальное | Stateless + Redis sessions |
| Market Service | Вертикальное | Один источник данных |
| Order Service | Горизонтальное | Sharding by account_id |
| PostgreSQL | Горизонтальное | Sharding + Read replicas |
| Redis | Горизонтальное | Cluster mode |
| RabbitMQ | Горизонтальное | Cluster + Mirrored queues |

### 2.5 Оценка пропускной способности

| Метрика | Single Instance | Scaled (N=10) |
|---------|-----------------|---------------|
| Orders/sec | ~1,000 | ~10,000 |
| Quotes updates/sec | ~10,000 | ~10,000 (broadcast) |
| Concurrent users | ~5,000 | ~50,000 |
| Database connections | 100 | 1,000 (pooled) |

### 2.6 Важные замечания

**Финансовые данные (балансы, позиции) нельзя переносить в Redis без гарантий:**

- ACID обязателен для финансовых операций
- Redis может терять данные при crash (даже с AOF)
- Решение: PostgreSQL для write + Redis read-replica для отображения

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              ГИБРИДНЫЙ ПОДХОД ДЛЯ ФИНАНСОВЫХ ДАННЫХ                         │
└─────────────────────────────────────────────────────────────────────────────┘

  Write Path (ACID)                    Read Path (Speed)
       │                                     │
       ▼                                     ▼
  ┌─────────────┐                      ┌─────────────┐
  │ PostgreSQL  │ ────── CDC ────────▶ │   Redis     │
  │   Master    │      (Debezium)      │   Cache     │
  │             │                      │             │
  │ • Balances  │                      │ • Balances  │
  │ • Positions │                      │ • Positions │
  │             │                      │ (read-only) │
  └─────────────┘                      └─────────────┘
        │                                     │
        │                                     │
   Strong                               Eventual
   Consistency                          Consistency
   (операции)                           (отображение)
```

---

## Заключение

### По вопросу 1 (Гарантированная доставка)

В проекте реализованы базовые паттерны надёжной доставки: **Manual Acknowledgment** и **Idempotency Pattern**. Персистентность реализована частично: **Durable Exchange** настроен, однако очереди используют режим `exclusive` (не переживают рестарт), а сообщения отправляются без флага `persistent`.

**Для production-окружения рекомендуется:**
- Перевести очереди в режим `durable`
- Устанавливать `delivery_mode=2` для сообщений
- Добавить **Transactional Outbox** для атомарности "БД + событие"
- Реализовать **Publisher Confirms** для подтверждения доставки

### По вопросу 2 (Масштабирование)

Предложена архитектура, основанная на:

1. **Разделении сервисов** по характеру нагрузки (market-service vs order-service)
2. **CQRS** для оптимизации read/write операций
3. **Горизонтальном партиционировании** по account_id
4. **Гибридном хранении** (PostgreSQL для ACID, Redis для скорости, TimescaleDB для истории)

Данная архитектура обеспечивает линейное масштабирование и позволяет обрабатывать до 10,000+ ордеров в секунду при соответствующем количестве инстансов.

---

*Отчёт подготовлен в рамках защиты курсовой работы по курсу "Microservice Architecture" (OTUS)*
